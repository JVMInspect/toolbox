package land.src.toolbox.jvm.util

// constant pool constant types - from JVM spec.
const val JVM_CONSTANT_Utf8 = 1
const val JVM_CONSTANT_Unicode = 2 // unused
const val JVM_CONSTANT_Integer = 3
const val JVM_CONSTANT_Float = 4
const val JVM_CONSTANT_Long = 5
const val JVM_CONSTANT_Double = 6
const val JVM_CONSTANT_Class = 7
const val JVM_CONSTANT_String = 8
const val JVM_CONSTANT_Fieldref = 9
const val JVM_CONSTANT_Methodref = 10
const val JVM_CONSTANT_InterfaceMethodref = 11
const val JVM_CONSTANT_NameAndType = 12
const val JVM_CONSTANT_MethodHandle = 15
const val JVM_CONSTANT_MethodType = 16
const val JVM_CONSTANT_Dynamic = 17
const val JVM_CONSTANT_InvokeDynamic = 18
const val JVM_CONSTANT_Module = 19
const val JVM_CONSTANT_Package = 20

// JVM_CONSTANT_MethodHandle subtypes
const val JVM_REF_getField = 1
const val JVM_REF_getStatic = 2
const val JVM_REF_putField = 3
const val JVM_REF_putStatic = 4
const val JVM_REF_invokeVirtual = 5
const val JVM_REF_invokeStatic = 6
const val JVM_REF_invokeSpecial = 7
const val JVM_REF_newInvokeSpecial = 8
const val JVM_REF_invokeInterface = 9

// HotSpot specific constant pool constant types.
const val JVM_CONSTANT_Invalid = 0
const val JVM_CONSTANT_UnresolvedClass = 100  // Temporary tag until actual use
const val JVM_CONSTANT_ClassIndex = 101  // Temporary tag while constructing constant pool
const val JVM_CONSTANT_StringIndex = 102  // Temporary tag while constructing constant pool
const val JVM_CONSTANT_UnresolvedClassInError = 103  // Error tag due to resolution error
const val JVM_CONSTANT_MethodHandleInError = 104  // Error tag due to resolution error
const val JVM_CONSTANT_MethodTypeInError = 105  // Error tag due to resolution error

// 1.5 major/minor version numbers from JVM spec. 3rd edition
const val MAJOR_VERSION: Short = 49
const val MINOR_VERSION: Short = 0
const val MAJOR_VERSION_OLD: Short = 46
const val MINOR_VERSION_OLD: Short = 0

// From jvm.h
const val JVM_ACC_PUBLIC = 0x0001 // visible to everyone
const val JVM_ACC_PRIVATE = 0x0002 // visible only to the defining class
const val JVM_ACC_PROTECTED = 0x0004 // visible to subclasses
const val JVM_ACC_STATIC = 0x0008 // instance variable is static
const val JVM_ACC_FINAL = 0x0010 // no further subclassing; overriding
const val JVM_ACC_SYNCHRONIZED = 0x0020 // wrap method call in monitor lock
const val JVM_ACC_SUPER = 0x0020 // funky handling of invokespecial
const val JVM_ACC_VOLATILE = 0x0040 // can not cache in registers
const val JVM_ACC_BRIDGE = 0x0040 // bridge method generated by compiler
const val JVM_ACC_TRANSIENT = 0x0080 // not persistent
const val JVM_ACC_VARARGS = 0x0080 // method declared with variable number of args
const val JVM_ACC_NATIVE = 0x0100 // implemented in C
const val JVM_ACC_INTERFACE = 0x0200 // class is an interface
const val JVM_ACC_ABSTRACT = 0x0400 // no definition provided
const val JVM_ACC_STRICT = 0x0800 // strict floating point
const val JVM_ACC_SYNTHETIC = 0x1000 // compiler-generated class; method or field
const val JVM_ACC_ANNOTATION = 0x2000 // annotation type
const val JVM_ACC_ENUM = 0x4000 // field is declared as element of enum

// from accessFlags.hpp - hotspot internal flags
const val JVM_ACC_WRITTEN_FLAGS = 0x00007FFF // flags actually put in .class file

// flags accepted by set_field_flags
const val JVM_ACC_FIELD_FLAGS = 0x00008000 or JVM_ACC_WRITTEN_FLAGS

// from jvm.h
const val JVM_RECOGNIZED_CLASS_MODIFIERS = JVM_ACC_PUBLIC or
        JVM_ACC_FINAL or
        JVM_ACC_SUPER or
        JVM_ACC_INTERFACE or
        JVM_ACC_ABSTRACT or
        JVM_ACC_ANNOTATION or
        JVM_ACC_ENUM or
        JVM_ACC_SYNTHETIC

const val JVM_RECOGNIZED_FIELD_MODIFIERS = JVM_ACC_PUBLIC or
        JVM_ACC_PRIVATE or
        JVM_ACC_PROTECTED or
        JVM_ACC_STATIC or
        JVM_ACC_FINAL or
        JVM_ACC_VOLATILE or
        JVM_ACC_TRANSIENT or
        JVM_ACC_ENUM or
        JVM_ACC_SYNTHETIC

const val JVM_RECOGNIZED_METHOD_MODIFIERS = JVM_ACC_PUBLIC or
        JVM_ACC_PRIVATE or
        JVM_ACC_PROTECTED or
        JVM_ACC_STATIC or
        JVM_ACC_FINAL or
        JVM_ACC_SYNCHRONIZED or
        JVM_ACC_BRIDGE or
        JVM_ACC_VARARGS or
        JVM_ACC_NATIVE or
        JVM_ACC_ABSTRACT or
        JVM_ACC_STRICT or
        JVM_ACC_SYNTHETIC

// hotspot specific internal flags

// Method* flags
const val JVM_ACC_MONITOR_MATCH = 0x10000000 // True if we know that monitorenter/monitorexit bytecodes match
const val JVM_ACC_HAS_MONITOR_BYTECODES = 0x20000000 // Method contains monitorenter/monitorexit bytecodes
const val JVM_ACC_HAS_LOOPS = 0x40000000 // Method has loops
const val JVM_ACC_LOOPS_FLAG_INIT = 0x80000000.toInt() // The loop flag has been initialized
const val JVM_ACC_QUEUED = 0x01000000 // Queued for compilation
const val JVM_ACC_NOT_C2_COMPILABLE = 0x02000000
const val JVM_ACC_NOT_C1_COMPILABLE = 0x04000000
const val JVM_ACC_NOT_C2_OSR_COMPILABLE = 0x08000000
const val JVM_ACC_HAS_LINE_NUMBER_TABLE = 0x00100000
const val JVM_ACC_HAS_CHECKED_EXCEPTIONS = 0x00400000
const val JVM_ACC_HAS_JSRS = 0x00800000
const val JVM_ACC_IS_OLD = 0x00010000 // RedefineClasses() has replaced this method
const val JVM_ACC_IS_OBSOLETE = 0x00020000 // RedefineClasses() has made method obsolete
const val JVM_ACC_IS_PREFIXED_NATIVE = 0x00040000 // JVMTI has prefixed this native method
const val JVM_ACC_ON_STACK = 0x00080000 // RedefineClasses() was used on the stack
const val JVM_ACC_IS_DELETED = 0x00008000 // RedefineClasses() has deleted this method

// Klass* flags
const val JVM_ACC_HAS_MIRANDA_METHODS = 0x10000000 // True if this class has miranda methods in its vtable
const val JVM_ACC_HAS_VANILLA_CONSTRUCTOR = 0x20000000 // True if klass has a vanilla default constructor
const val JVM_ACC_HAS_FINALIZER = 0x40000000 // True if klass has a non-empty finalize() method
const val JVM_ACC_IS_CLONEABLE_FAST = 0x80000000.toInt() // True if klass implements Cloneable and can be optimized in generated code
const val JVM_ACC_HAS_FINAL_METHOD = 0x01000000 // True if klass has final method
const val JVM_ACC_IS_SHARED_CLASS = 0x02000000 // True if klass is shared
const val JVM_ACC_IS_HIDDEN_CLASS = 0x04000000 // True if klass is hidden
const val JVM_ACC_IS_VALUE_BASED_CLASS = 0x08000000 // True if klass is marked as a ValueBased class

// Klass* and Method* flags
const val JVM_ACC_HAS_LOCAL_VARIABLE_TABLE = 0x00200000
const val JVM_ACC_PROMOTED_FLAGS = 0x00200000 // flags promoted from methods to the holding klass

// field flags
const val JVM_ACC_FIELD_ACCESS_WATCHED = 0x00002000 // field access is watched by JVMTI
const val JVM_ACC_FIELD_MODIFICATION_WATCHED = 0x00008000 // field modification is watched by JVMTI
const val JVM_ACC_FIELD_INTERNAL = 0x00000400 // internal field; same as JVM_ACC_ABSTRACT
const val JVM_ACC_FIELD_STABLE = 0x00000020 // @Stable field; same as JVM_ACC_SYNCHRONIZED and JVM_ACC_SUPER
const val JVM_ACC_FIELD_INITIALIZED_FINAL_UPDATE = 0x00000100 // (static) final field updated outside (class) initializer; same as JVM_ACC_NATIVE
const val JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE = 0x00000800 // field has generic signature